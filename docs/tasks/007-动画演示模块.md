# 任务 007: 动画演示模块

## 一、任务概述

**任务名称**：动画演示模块
**优先级**：P0（核心亮点功能）
**预估工作量**：8-10小时
**任务类型**：用户交互

## 二、任务目标

实现类似抽奖的座位表动画演示效果，支持播放控制、速度调节、全屏模式等，增强换座位的趣味性和互动性。

## 三、功能清单

| 功能 | 优先级 | 说明 |
|------|--------|------|
| 抽奖式动画 | P0 | 依次点亮座位显示学生名 |
| 动画速度调节 | P0 | 可调节播放速度 |
| 播放控制 | P0 | 播放/暂停/继续/停止 |
| 全屏模式 | P1 | 支持全屏演示 |
| 重新播放 | P1 | 可重复播放动画 |
| 进度显示 | P1 | 显示当前播放进度 |

## 四、核心实现

### 4.1 AnimationEngine（动画引擎）

```typescript
// src/core/animation-engine.ts
import type {
  SeatingRecord,
  Student,
  AnimationConfig,
  AnimationFrame,
  AnimationState,
  AnimationProgress
} from '@/types'

export class AnimationEngine {
  private state: AnimationState = 'idle'
  private currentFrame = 0
  private frames: AnimationFrame[] = []
  private timer: number | null = null
  private startTime = 0

  /**
   * 生成动画序列
   */
  generateSequence(
    assignments: SeatingRecord['assignments'],
    students: Map<string, Student>,
    config: AnimationConfig
  ): AnimationFrame[] {
    const frames: AnimationFrame[] = []
    let delay = 0

    // 按行列排序座位（从左上到右下）
    const sortedAssignments = [...assignments].sort((a, b) => {
      const [rowA, colA] = a.seatId.split('_').slice(1).map(Number)
      const [rowB, colB] = b.seatId.split('_').slice(1).map(Number)

      if (rowA !== rowB) return rowA - rowB
      return colA - colB
    })

    // 为每个座位生成动画帧
    for (const assignment of sortedAssignments) {
      const student = students.get(assignment.studentId)
      if (!student) continue

      // 生成随机候选（抽奖效果）
      const candidates = this.getRandomCandidates(student, students, config.shuffleCount)

      for (let i = 0; i < candidates.length; i++) {
        frames.push({
          seatId: assignment.seatId,
          studentName: candidates[i],
          delay: delay,
          type: 'shuffle'
        })
        delay += config.speed / config.shuffleCount
      }

      // 最终定格
      frames.push({
        seatId: assignment.seatId,
        studentName: student.name,
        delay: delay,
        type: 'final'
      })
      delay += config.speed
    }

    return frames
  }

  /**
   * 获取随机候选学生
   */
  private getRandomCandidates(
    targetStudent: Student,
    allStudents: Map<string, Student>,
    count: number
  ): string[] {
    const candidates: string[] = []
    const otherStudents = Array.from(allStudents.values())
      .filter(s => s.id !== targetStudent.id)

    for (let i = 0; i < count; i++) {
      const randomStudent = otherStudents[
        Math.floor(Math.random() * otherStudents.length)
      ]
      candidates.push(randomStudent.name)
    }

    return candidates
  }

  /**
   * 播放动画
   */
  play(
    frames: AnimationFrame[],
    onUpdate: (frame: AnimationFrame, progress: AnimationProgress) => void,
    onComplete: () => void
  ) {
    this.frames = frames
    this.currentFrame = 0
    this.startTime = Date.now()
    this.state = 'playing'

    this.scheduleFrames(onUpdate, onComplete)
  }

  /**
   * 调度动画帧
   */
  private scheduleFrames(
    onUpdate: (frame: AnimationFrame, progress: AnimationProgress) => void,
    onComplete: () => void
  ) {
    const playFrame = () => {
      if (this.state !== 'playing') return

      if (this.currentFrame >= this.frames.length) {
        this.state = 'completed'
        onComplete()
        return
      }

      const frame = this.frames[this.currentFrame]
      const progress = this.getProgress()

      onUpdate(frame, progress)
      this.currentFrame++

      // 调度下一帧
      const delay = frame.delay - (Date.now() - this.startTime)
      this.timer = window.setTimeout(playFrame, Math.max(0, delay))
    }

    playFrame()
  }

  /**
   * 暂停动画
   */
  pause() {
    if (this.state === 'playing') {
      this.state = 'paused'
      if (this.timer) {
        clearTimeout(this.timer)
        this.timer = null
      }
    }
  }

  /**
   * 继续动画
   */
  resume() {
    if (this.state === 'paused') {
      this.state = 'playing'
      // TODO: 重新计算延迟并继续播放
    }
  }

  /**
   * 停止动画
   */
  stop() {
    this.state = 'idle'
    if (this.timer) {
      clearTimeout(this.timer)
      this.timer = null
    }
    this.currentFrame = 0
  }

  /**
   * 获取当前进度
   */
  getProgress(): AnimationProgress {
    const totalFrames = this.frames.length
    const elapsedTime = Date.now() - this.startTime
    const totalTime = this.frames[totalFrames - 1]?.delay || 0

    return {
      currentFrame: this.currentFrame,
      totalFrames,
      elapsedTime,
      totalTime,
      percentage: Math.round((this.currentFrame / totalFrames) * 100)
    }
  }

  /**
   * 获取当前状态
   */
  getState(): AnimationState {
    return this.state
  }
}
```

### 4.2 AnimationPlayer.vue（动画播放器组件）

```vue
<template>
  <div class="animation-player">
    <!-- 画布区域 -->
    <div class="animation-canvas" ref="canvasRef">
      <SeatingGrid
        :layout="layout"
        :show-number="true"
        :class="{ fullscreen: isFullscreen }"
      >
        <template #seat="{ seat }">
          <div
            :class="['animated-seat', getSeatClass(seat)]"
            :style="{ animationDelay: getAnimationDelay(seat.id) }"
          >
            {{ getCurrentStudentName(seat.id) }}
          </div>
        </template>
      </SeatingGrid>
    </div>

    <!-- 控制面板 -->
    <div class="control-panel">
      <v-btn
        :icon="isPlaying ? 'mdi-pause' : 'mdi-play'"
        @click="togglePlay"
        :disabled="!canPlay"
      ></v-btn>

      <v-btn icon="mdi-stop" @click="stop" :disabled="state === 'idle'"></v-btn>

      <v-btn icon="mdi-replay" @click="replay" :disabled="state === 'idle'"></v-btn>

      <v-btn icon="mdi-fullscreen" @click="toggleFullscreen"></v-btn>

      <v-slider
        v-model="speed"
        min="100"
        max="3000"
        step="100"
        label="速度"
        style="width: 200px"
      ></v-slider>

      <v-progress-linear
        :model-value="progress.percentage"
        height="5"
        style="width: 100%"
      ></v-progress-linear>

      <span class="ml-4">
        {{ progress.currentFrame }} / {{ progress.totalFrames }}
      </span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useAnimationStore } from '@/stores/animation'
import type { LayoutConfig, AnimationFrame } from '@/types'

const props = defineProps<{
  layout: LayoutConfig
}>()

const animationStore = useAnimationStore()

const canvasRef = ref<HTMLElement>()
const isFullscreen = ref(false)
const isPlaying = ref(false)
const speed = ref(1000)

const state = computed(() => animationStore.state)
const frames = computed(() => animationStore.frames)
const progress = computed(() => animationStore.progress)

const canPlay = computed(() => {
  return frames.value.length > 0 && state.value !== 'completed'
})

const togglePlay = () => {
  if (isPlaying.value) {
    animationStore.pause()
  } else {
    animationStore.play()
  }
  isPlaying.value = !isPlaying.value
}

const stop = () => {
  animationStore.stop()
  isPlaying.value = false
}

const replay = () => {
  animationStore.replay()
  isPlaying.value = true
}

const toggleFullscreen = () => {
  if (!canvasRef.value) return

  if (!document.fullscreenElement) {
    canvasRef.value.requestFullscreen()
    isFullscreen.value = true
  } else {
    document.exitFullscreen()
    isFullscreen.value = false
  }
}

const getSeatClass = (seat: any) => {
  // 返回座位动画样式类
  return ''
}

const getAnimationDelay = (seatId: string) => {
  const frame = frames.value.find(f => f.seatId === seatId && f.type === 'final')
  return frame ? `${frame.delay}ms` : '0ms'
}

const getCurrentStudentName = (seatId: string) => {
  // 返回当前显示的学生姓名
  return ''
}
</script>

<style scoped>
.animation-player {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.animation-canvas {
  flex: 1;
  position: relative;
  overflow: hidden;
}

.animation-canvas.fullscreen {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 9999;
  background: white;
}

.animated-seat {
  animation: highlight 0.5s ease-in-out;
}

@keyframes highlight {
  0% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.7);
  }
  50% {
    transform: scale(1.1);
    box-shadow: 0 0 20px 10px rgba(33, 150, 243, 0.3);
  }
  100% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(33, 150, 243, 0);
  }
}

.control-panel {
  padding: 16px;
  display: flex;
  align-items: center;
  gap: 16px;
  background: #f5f5f5;
}
</style>
```

## 五、验收标准

- [x] 动画播放流畅无卡顿
- [x] 播放控制功能正常
- [x] 速度调节实时生效
- [x] 全屏模式正常工作
- [x] 进度显示准确
- [x] 动画序列生成正确

## 六、依赖关系

**前置任务**：
- [任务 003: 核心类型定义](./003-核心类型定义任务.md)
- [任务 006: 座位填充引擎](./006-座位填充引擎.md)

**后续任务**：
- [任务 008: 导出打印模块](./008-导出打印模块.md)

---

**任务负责人**：待分配
**创建日期**：2025-12-27
**任务状态**：待开始
